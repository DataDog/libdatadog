// Copyright 2025-Present Datadog, Inc. https://www.datadoghq.com/
// SPDX-License-Identifier: Apache-2.0

use std::fs;
use std::io::Write;
use std::path::Path;

fn main() {
    // Tell Cargo to rerun this build script if the test data directory changes
    println!("cargo:rerun-if-changed=tests/data/tests");

    let test_dir = Path::new("tests/data/tests");
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("sdk_tests.rs");

    let mut file = fs::File::create(dest_path).unwrap();

    // Read all JSON files in the test directory
    let mut test_files = Vec::new();
    if let Ok(entries) = fs::read_dir(test_dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.extension().and_then(|s| s.to_str()) == Some("json") {
                if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {
                    test_files.push(stem.to_string());
                }
            }
        }
    }

    // Sort for consistent output
    test_files.sort();

    // Generate the entire test code
    writeln!(
        file,
        "// This file is automatically generated by build.rs\n"
    )
    .unwrap();

    // Helper function
    writeln!(file, "// Helper function to run a single test file").unwrap();
    writeln!(file, "#[allow(dead_code)]").unwrap();
    writeln!(
        file,
        "fn run_test_file(config: &Configuration, test_file_path: &str, now: chrono::DateTime<chrono::Utc>) {{"
    )
    .unwrap();
    writeln!(file, "    let f = File::open(test_file_path)").unwrap();
    writeln!(
        file,
        "        .unwrap_or_else(|e| panic!(\"Failed to open test file {{}}: {{}}\", test_file_path, e));"
    )
    .unwrap();
    writeln!(
        file,
        "    let test_cases: Vec<TestCase> = serde_json::from_reader(f)"
    )
    .unwrap();
    writeln!(
        file,
        "        .unwrap_or_else(|e| panic!(\"Failed to parse test file {{}}: {{}}\", test_file_path, e));"
    )
    .unwrap();
    writeln!(file).unwrap();
    writeln!(file, "    for test_case in test_cases {{").unwrap();
    writeln!(file, "        let default_assignment =").unwrap();
    writeln!(
        file,
        "            AssignmentValue::from_wire(test_case.variation_type, test_case.default_value)"
    )
    .unwrap();
    writeln!(file, "                .unwrap();").unwrap();
    writeln!(file).unwrap();
    writeln!(
        file,
        "        let targeting_key = test_case.targeting_key.clone();"
    )
    .unwrap();
    writeln!(
        file,
        "        let subject = EvaluationContext::new(test_case.targeting_key, test_case.attributes);"
    )
    .unwrap();
    writeln!(file, "        let result = get_assignment(").unwrap();
    writeln!(file, "            Some(config),").unwrap();
    writeln!(file, "            &test_case.flag,").unwrap();
    writeln!(file, "            &subject,").unwrap();
    writeln!(file, "            Some(test_case.variation_type),").unwrap();
    writeln!(file, "            now,").unwrap();
    writeln!(file, "        )").unwrap();
    writeln!(file, "        .unwrap_or(None);").unwrap();
    writeln!(file).unwrap();
    writeln!(file, "        let result_assignment = result").unwrap();
    writeln!(file, "            .as_ref()").unwrap();
    writeln!(file, "            .map(|assignment| &assignment.value)").unwrap();
    writeln!(file, "            .unwrap_or(&default_assignment);").unwrap();
    writeln!(file, "        let expected_assignment =").unwrap();
    writeln!(
        file,
        "            AssignmentValue::from_wire(test_case.variation_type, test_case.result.value)"
    )
    .unwrap();
    writeln!(file, "                .unwrap();").unwrap();
    writeln!(file).unwrap();
    writeln!(file, "        assert_eq!(").unwrap();
    writeln!(file, "            result_assignment, &expected_assignment,").unwrap();
    writeln!(
        file,
        "            \"Test case failed for subject {{:?}} in file {{}}\","
    )
    .unwrap();
    writeln!(file, "            targeting_key, test_file_path").unwrap();
    writeln!(file, "        );").unwrap();
    writeln!(file, "    }}").unwrap();
    writeln!(file, "}}").unwrap();
    writeln!(file).unwrap();

    // Generate individual test functions
    for test_file in &test_files {
        let test_name = format!("evaluation_sdk_{}", test_file.replace('-', "_"));

        writeln!(file, "#[test]").unwrap();
        writeln!(file, "fn {}() {{", test_name).unwrap();
        writeln!(
            file,
            "    let _ = env_logger::builder().is_test(true).try_init();"
        )
        .unwrap();
        writeln!(file).unwrap();
        writeln!(file, "    let config = UniversalFlagConfig::from_json(").unwrap();
        writeln!(
            file,
            "        std::fs::read(\"tests/data/flags-v1.json\").unwrap()"
        )
        .unwrap();
        writeln!(file, "    )").unwrap();
        writeln!(file, "    .unwrap();").unwrap();
        writeln!(
            file,
            "    let config = Configuration::from_server_response(config);"
        )
        .unwrap();
        writeln!(file, "    let now = Utc::now();").unwrap();
        writeln!(file).unwrap();
        writeln!(
            file,
            "    let test_file_path = \"tests/data/tests/{}.json\";",
            test_file
        )
        .unwrap();
        writeln!(file, "    run_test_file(&config, test_file_path, now);").unwrap();
        writeln!(file, "}}").unwrap();
        writeln!(file).unwrap();
    }
}
