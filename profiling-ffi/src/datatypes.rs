// Copyright 2021-Present Datadog, Inc. https://www.datadoghq.com/
// SPDX-License-Identifier: Apache-2.0

use datadog_profiling::api;
use ddcommon_ffi::slice::{AsBytes, CharSlice, Slice};
use std::result::Result;
use std::str::Utf8Error;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ValueType<'a> {
    pub type_: CharSlice<'a>,
    pub unit: CharSlice<'a>,
}

impl<'a> ValueType<'a> {
    pub fn new(type_: &'a str, unit: &'a str) -> Self {
        Self {
            type_: type_.into(),
            unit: unit.into(),
        }
    }
}

#[repr(C)]
pub struct Period<'a> {
    pub type_: ValueType<'a>,
    pub value: i64,
}

#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct Label<'a> {
    pub key: CharSlice<'a>,

    /// At most one of the following must be present
    pub str: CharSlice<'a>,
    pub num: i64,

    /// Should only be present when num is present.
    /// Specifies the units of num.
    /// Use arbitrary string (for example, "requests") as a custom count unit.
    /// If no unit is specified, consumer may apply heuristic to deduce the unit.
    /// Consumers may also  interpret units like "bytes" and "kilobytes" as memory
    /// units and units like "seconds" and "nanoseconds" as time units,
    /// and apply appropriate unit conversions to these.
    pub num_unit: CharSlice<'a>,
}

#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct Function<'a> {
    /// Name of the function, in human-readable form if available.
    pub name: CharSlice<'a>,

    /// Name of the function, as identified by the system.
    /// For instance, it can be a C++ mangled name.
    pub system_name: CharSlice<'a>,

    /// Source file containing the function.
    pub filename: CharSlice<'a>,

    /// Line number in source file.
    pub start_line: i64,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct Line<'a> {
    /// The corresponding profile.Function for this line.
    pub function: Function<'a>,

    /// Line number in source code.
    pub line: i64,
}

#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct Location<'a> {
    /// todo: how to handle unknown mapping?
    pub mapping: Mapping<'a>,
    pub function: Function<'a>,

    /// The instruction address for this location, if available.  It
    /// should be within [Mapping.memory_start...Mapping.memory_limit]
    /// for the corresponding mapping. A non-leaf address may be in the
    /// middle of a call instruction. It is up to display tools to find
    /// the beginning of the instruction if necessary.
    pub address: u64,
    pub line: i64,
}

#[repr(C)]
#[derive(Copy, Clone, Default)]
pub struct Mapping<'a> {
    /// Address at which the binary (or DLL) is loaded into memory.
    pub memory_start: u64,

    /// The limit of the address range occupied by this mapping.
    pub memory_limit: u64,

    /// Offset in the binary that corresponds to the first mapped address.
    pub file_offset: u64,

    /// The object this entry is loaded from.  This can be a filename on
    /// disk for the main binary and shared libraries, or virtual
    /// abstractions like "[vdso]".
    pub filename: CharSlice<'a>,

    /// A string that uniquely identifies a particular program version
    /// with high probability. E.g., for binaries generated by GNU tools,
    /// it could be the contents of the .note.gnu.build-id field.
    pub build_id: CharSlice<'a>,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct Sample<'a> {
    /// The leaf is at locations[0].
    pub locations: Slice<'a, Location<'a>>,

    /// The type and unit of each value is defined by the corresponding
    /// entry in Profile.sample_type. All samples must have the same
    /// number of values, the same as the length of Profile.sample_type.
    /// When aggregating multiple samples into a single sample, the
    /// result has a list of values that is the element-wise sum of the
    /// lists of the originals.
    pub values: Slice<'a, i64>,

    /// label includes additional context for this sample. It can include
    /// things like a thread id, allocation size, etc
    pub labels: Slice<'a, Label<'a>>,
}

impl<'a> TryFrom<&'a Mapping<'a>> for api::Mapping<'a> {
    type Error = Utf8Error;

    fn try_from(mapping: &'a Mapping<'a>) -> Result<Self, Self::Error> {
        let filename = mapping.filename.try_to_utf8()?;
        let build_id = mapping.build_id.try_to_utf8()?;
        Ok(Self {
            memory_start: mapping.memory_start,
            memory_limit: mapping.memory_limit,
            file_offset: mapping.file_offset,
            filename,
            build_id,
        })
    }
}

impl<'a> From<&'a ValueType<'a>> for api::ValueType<'a> {
    fn from(vt: &'a ValueType<'a>) -> Self {
        Self::new(
            vt.type_.try_to_utf8().unwrap_or(""),
            vt.unit.try_to_utf8().unwrap_or(""),
        )
    }
}

impl<'a> From<&'a Period<'a>> for api::Period<'a> {
    fn from(period: &'a Period<'a>) -> Self {
        Self {
            r#type: api::ValueType::from(&period.type_),
            value: period.value,
        }
    }
}

impl<'a> TryFrom<&'a Function<'a>> for api::Function<'a> {
    type Error = Utf8Error;

    fn try_from(function: &'a Function<'a>) -> Result<Self, Self::Error> {
        let name = function.name.try_to_utf8()?;
        let system_name = function.system_name.try_to_utf8()?;
        let filename = function.filename.try_to_utf8()?;
        Ok(Self {
            name,
            system_name,
            filename,
            start_line: function.start_line,
        })
    }
}

impl<'a> TryFrom<&'a Line<'a>> for api::Line<'a> {
    type Error = Utf8Error;

    fn try_from(line: &'a Line<'a>) -> Result<Self, Self::Error> {
        Ok(Self {
            function: api::Function::try_from(&line.function)?,
            line: line.line,
        })
    }
}

impl<'a> TryFrom<&'a Location<'a>> for api::Location<'a> {
    type Error = Utf8Error;

    fn try_from(location: &'a Location<'a>) -> Result<Self, Self::Error> {
        let mapping = api::Mapping::try_from(&location.mapping)?;
        let function = api::Function::try_from(&location.function)?;
        Ok(Self {
            mapping,
            function,
            address: location.address,
            line: location.line,
        })
    }
}

impl<'a> TryFrom<&'a Label<'a>> for api::Label<'a> {
    type Error = Utf8Error;

    fn try_from(label: &'a Label<'a>) -> Result<Self, Self::Error> {
        let key = label.key.try_to_utf8()?;
        let str = label.str.try_to_utf8()?;
        let str = if str.is_empty() { None } else { Some(str) };
        let num_unit = label.num_unit.try_to_utf8()?;
        let num_unit = if num_unit.is_empty() {
            None
        } else {
            Some(num_unit)
        };

        Ok(Self {
            key,
            str,
            num: label.num,
            num_unit,
        })
    }
}

impl<'a> TryFrom<Sample<'a>> for api::Sample<'a> {
    type Error = Utf8Error;

    fn try_from(sample: Sample<'a>) -> Result<Self, Self::Error> {
        let mut locations: Vec<api::Location> = Vec::with_capacity(sample.locations.len());

        for location in sample.locations.as_slice().iter() {
            locations.push(location.try_into()?)
        }

        let values: Vec<i64> = sample.values.into_slice().to_vec();

        let mut labels: Vec<api::Label> = Vec::with_capacity(sample.labels.len());
        for label in sample.labels.as_slice().iter() {
            labels.push(label.try_into()?);
        }

        Ok(Self {
            locations,
            values,
            labels,
        })
    }
}
