// Copyright 2024-Present Datadog, Inc. https://www.datadoghq.com/
// SPDX-License-Identifier: Apache-2.0

use super::*;
use crate::collections::identifiable::FxIndexMap;
use crate::internal::{owned_types, Profile, Timestamp};
use crate::pprof;
use bolero::TypeGenerator;
use bolero_generator::{TypeGeneratorWithParams, ValueGenerator};
use std::collections::{HashMap, HashSet};
use std::time::SystemTime;

#[derive(Clone, Debug, Default, Eq, PartialEq, Hash, TypeGenerator)]
pub struct Function {
    /// Name of the function, in human-readable form if available.
    pub name: Box<str>,

    /// Name of the function, as identified by the system.
    /// For instance, it can be a C++ mangled name.
    pub system_name: Box<str>,

    /// Source file containing the function.
    pub filename: Box<str>,

    /// Line number in source file.
    pub start_line: i64,
}

impl Function {
    pub fn new(name: Box<str>, system_name: Box<str>, filename: Box<str>, start_line: i64) -> Self {
        Self {
            name,
            system_name,
            filename,
            start_line,
        }
    }
}

impl<'a> From<&'a Function> for api::Function<'a> {
    fn from(value: &'a Function) -> Self {
        Self {
            name: &value.name,
            system_name: &value.system_name,
            filename: &value.filename,
            start_line: value.start_line,
        }
    }
}

#[derive(Clone, Debug, Default, TypeGenerator)]
pub struct Label {
    pub key: Box<str>,

    /// At most one of the following must be present
    pub str: Option<Box<str>>,
    pub num: i64,

    /// Should only be present when num is present.
    /// Specifies the units of num.
    /// Use arbitrary string (for example, "requests") as a custom count unit.
    /// If no unit is specified, consumer may apply heuristic to deduce the unit.
    /// Consumers may also  interpret units like "bytes" and "kilobytes" as memory
    /// units and units like "seconds" and "nanoseconds" as time units,
    /// and apply appropriate unit conversions to these.
    pub num_unit: Option<Box<str>>,
}

impl<'a> From<&'a Label> for api::Label<'a> {
    fn from(value: &'a Label) -> Self {
        Self {
            key: &value.key,
            str: value.str.as_deref(),
            num: value.num,
            num_unit: value.num_unit.as_deref(),
        }
    }
}

#[derive(Clone, Debug, Eq, PartialEq, TypeGenerator)]
pub struct Line {
    /// The corresponding profile.Function for this line.
    pub function: Function,

    /// Line number in source code.
    pub line: i64,
}

impl<'a> From<&'a Line> for api::Line<'a> {
    fn from(value: &'a Line) -> Self {
        Self {
            function: (&value.function).into(),
            line: value.line,
        }
    }
}

#[derive(Clone, Debug, Default, Eq, PartialEq, Hash, TypeGenerator)]
pub struct Location {
    pub mapping: Mapping,
    pub function: Function,

    /// The instruction address for this location, if available.  It
    /// should be within [Mapping.memory_start...Mapping.memory_limit]
    /// for the corresponding mapping. A non-leaf address may be in the
    /// middle of a call instruction. It is up to display tools to find
    /// the beginning of the instruction if necessary.
    pub address: u64,
    pub line: i64,
}

impl Location {
    pub fn new(mapping: Mapping, function: Function, address: u64, line: i64) -> Self {
        Self {
            mapping,
            function,
            address,
            line,
        }
    }
}

impl<'a> From<&'a Location> for api::Location<'a> {
    fn from(value: &'a Location) -> Self {
        Self {
            mapping: (&value.mapping).into(),
            function: (&value.function).into(),
            address: value.address,
            line: value.line,
        }
    }
}

#[derive(Clone, Debug, Default, Eq, PartialEq, Hash, TypeGenerator)]
pub struct Mapping {
    /// Address at which the binary (or DLL) is loaded into memory.
    pub memory_start: u64,

    /// The limit of the address range occupied by this mapping.
    pub memory_limit: u64,

    /// Offset in the binary that corresponds to the first mapped address.
    pub file_offset: u64,

    /// The object this entry is loaded from.  This can be a filename on
    /// disk for the main binary and shared libraries, or virtual
    /// abstractions like "[vdso]".
    pub filename: Box<str>,

    /// A string that uniquely identifies a particular program version
    /// with high probability. E.g., for binaries generated by GNU tools,
    /// it could be the contents of the .note.gnu.build-id field.
    pub build_id: Box<str>,
}

impl Mapping {
    pub fn new(
        memory_start: u64,
        memory_limit: u64,
        file_offset: u64,
        filename: Box<str>,
        build_id: Box<str>,
    ) -> Self {
        Self {
            memory_start,
            memory_limit,
            file_offset,
            filename,
            build_id,
        }
    }
}

impl<'a> From<&'a Mapping> for api::Mapping<'a> {
    fn from(value: &'a Mapping) -> Self {
        Self {
            memory_start: value.memory_start,
            memory_limit: value.memory_limit,
            file_offset: value.file_offset,
            filename: &value.filename,
            build_id: &value.build_id,
        }
    }
}

#[derive(Clone, Debug)]
pub struct Sample {
    /// The leaf is at locations[0].
    pub locations: Vec<Location>,

    /// The type and unit of each value is defined by the corresponding
    /// entry in Profile.sample_type. All samples must have the same
    /// number of values, the same as the length of Profile.sample_type.
    /// When aggregating multiple samples into a single sample, the
    /// result has a list of values that is the element-wise sum of the
    /// lists of the originals.
    pub values: Vec<i64>,

    /// label includes additional context for this sample. It can include
    /// things like a thread id, allocation size, etc
    pub labels: Vec<Label>,
}

impl<'a> From<&'a Sample> for api::Sample<'a> {
    fn from(value: &'a Sample) -> Self {
        Self {
            locations: value.locations.iter().map(api::Location::from).collect(),
            values: value.values.clone(),
            labels: value.labels.iter().map(api::Label::from).collect(),
        }
    }
}

/// PartialEq and Hash work on just the key to avoid getting duplicate
/// label keys.
impl PartialEq for Label {
    fn eq(&self, other: &Self) -> bool {
        self.key == other.key
    }
}

impl Eq for Label {}

/// PartialEq and Hash work on just the key to avoid getting duplicate
/// label keys.
impl std::hash::Hash for Label {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.key.hash(state)
    }
}
impl TypeGenerator for Sample {
    fn generate<D: bolero_generator::Driver>(driver: &mut D) -> Option<Self> {
        let locations = Vec::<Location>::gen_with().generate(driver)?;
        let values = Vec::<i64>::gen_with().generate(driver)?;
        let mut labels = std::collections::HashSet::<Label>::gen_with().generate(driver)?;

        // Ensure that the label has "local root span id" key
        // Generate non-zero num value for the label
        let num = i64::gen().generate(driver)?;
        // zero num is considered as invalid, see Profile::validate_sample_labels
        if num == 0 {
            return None;
        }

        labels.insert(Label {
            key: "local root span id".into(),
            str: None,
            num,
            num_unit: None,
        });
        let labels = labels.into_iter().collect();
        Some(Self {
            locations,
            values,
            labels,
        })
    }
}

fn assert_sample_types_eq(
    profile: &pprof::Profile,
    expected_sample_types: &[owned_types::ValueType],
) {
    assert_eq!(
        profile.sample_types.len(),
        expected_sample_types.len(),
        "Sample types length mismatch"
    );
    for (typ, expected_typ) in profile
        .sample_types
        .iter()
        .zip(expected_sample_types.iter())
    {
        assert_eq!(
            *profile.string_table[typ.r#type as usize],
            *expected_typ.r#typ
        );
        assert_eq!(*profile.string_table[typ.unit as usize], *expected_typ.unit);
    }
}

fn assert_samples_eq(
    profile: &pprof::Profile,
    samples_with_timestamps: &[&Sample],
    samples_without_timestamps: &HashMap<(&Vec<Location>, &Vec<Label>), Vec<i64>>,
    endpoint_mappings: &FxIndexMap<u64, &String>,
) {
    assert_eq!(
        profile.samples.len(),
        samples_with_timestamps.len() + samples_without_timestamps.len(),
        "Samples length mismatch"
    );

    let mut expected_timestamped_samples = samples_with_timestamps.iter();

    for sample in profile.samples.iter() {
        // Recreate owned_locations from vector of pprof::Location
        let mut owned_locations = Vec::new();
        for loc_id in sample.location_ids.iter() {
            let location = &profile.locations[*loc_id as usize - 1];
            let mapping = &profile.mappings[location.mapping_id as usize - 1];
            assert!(location.lines.len() == 1);
            let line = location.lines[0];
            let function = profile.functions[line.function_id as usize - 1];
            assert!(!location.is_folded);

            let owned_location = Location {
                mapping: Mapping {
                    memory_start: mapping.memory_start,
                    memory_limit: mapping.memory_limit,
                    file_offset: mapping.file_offset,
                    filename: profile.string_table[mapping.filename as usize]
                        .clone()
                        .into_boxed_str(),
                    build_id: profile.string_table[mapping.build_id as usize]
                        .clone()
                        .into_boxed_str(),
                },
                function: Function {
                    name: profile.string_table[function.name as usize]
                        .clone()
                        .into_boxed_str(),
                    system_name: profile.string_table[function.system_name as usize]
                        .clone()
                        .into_boxed_str(),
                    filename: profile.string_table[function.filename as usize]
                        .clone()
                        .into_boxed_str(),
                    start_line: function.start_line,
                },
                address: location.address,
                line: line.line,
            };

            owned_locations.push(owned_location);
        }

        // Recreate owned_labels from vector of pprof::Label
        let mut owned_labels = Vec::new();
        for label in sample.labels.iter() {
            let key = profile.string_table[label.key as usize]
                .clone()
                .into_boxed_str();

            if *key == *"end_timestamp_ns" {
                // TODO: Check end timestamp label
                continue;
            } else if *key == *"trace endpoint" {
                let actual_str = &profile.string_table[label.str as usize];

                let prev_label: &Label = owned_labels
                    .last()
                    .expect("Previous label to exist for endpoint label");
                let num = prev_label.num as u64;
                let expected_str = endpoint_mappings
                    .get(&num)
                    .expect("Endpoint mapping to exist");

                assert_eq!(actual_str, *expected_str);
                continue;
            }

            if label.str != 0 {
                let str = Box::from(profile.string_table[label.str as usize].as_str());
                owned_labels.push(Label {
                    key,
                    str: Some(str),
                    num: 0,
                    num_unit: None,
                });
            } else {
                let num = label.num;
                let num_unit = if label.num_unit != 0 {
                    Some(
                        profile.string_table[label.num_unit as usize]
                            .clone()
                            .into_boxed_str(),
                    )
                } else {
                    None
                };
                owned_labels.push(Label {
                    key,
                    str: None,
                    num,
                    num_unit,
                });
            }
        }

        if let Some(expected_sample) = expected_timestamped_samples.next() {
            assert_eq!(owned_locations, expected_sample.locations);
            assert_eq!(sample.values, expected_sample.values);
            assert_eq!(owned_labels, expected_sample.labels);
        } else {
            let key = (&owned_locations, &owned_labels);
            let expected_values = samples_without_timestamps
                .get(&key)
                .expect("Value not found for an aggregated sample");
            assert_eq!(&sample.values, expected_values);
        }
    }
}

fn fuzz_add_sample<'a>(
    timestamp: &Option<Timestamp>,
    sample: &'a Sample,
    expected_sample_types: &[owned_types::ValueType],
    profile: &mut Profile,
    samples_with_timestamps: &mut Vec<&'a Sample>,
    samples_without_timestamps: &mut HashMap<(&'a Vec<Location>, &'a Vec<Label>), Vec<i64>>,
) {
    let r = profile.add_sample(sample.into(), *timestamp);
    if expected_sample_types.len() == sample.values.len() {
        assert!(r.is_ok());
        if timestamp.is_some() {
            samples_with_timestamps.push(sample);
        } else if let Some(existing_values) =
            samples_without_timestamps.get_mut(&(&sample.locations, &sample.labels))
        {
            existing_values
                .iter_mut()
                .zip(sample.values.iter())
                .for_each(|(a, b)| *a = a.saturating_add(*b));
        } else {
            samples_without_timestamps
                .insert((&sample.locations, &sample.labels), sample.values.clone());
        }
    } else {
        assert!(r.is_err());
    }
}

/// Fuzzes adding a bunch of samples to the profile.
#[test]
fn test_fuzz_add_sample() {
    bolero::check!()
        .with_generator((
            Vec::<owned_types::ValueType>::gen(),
            Vec::<(Option<Timestamp>, Sample)>::gen(),
        ))
        .for_each(|(expected_sample_types, samples)| {
            let sample_types: Vec<_> = expected_sample_types
                .iter()
                .map(api::ValueType::from)
                .collect();
            let mut expected_profile = Profile::new(SystemTime::now(), &sample_types, None);
            let mut samples_with_timestamps = Vec::new();
            let mut samples_without_timestamps: HashMap<(&Vec<Location>, &Vec<Label>), Vec<i64>> =
                HashMap::new();
            for (timestamp, sample) in samples {
                fuzz_add_sample(
                    timestamp,
                    sample,
                    expected_sample_types,
                    &mut expected_profile,
                    &mut samples_with_timestamps,
                    &mut samples_without_timestamps,
                );
            }
            let profile = pprof::roundtrip_to_pprof(expected_profile).unwrap();
            assert_sample_types_eq(&profile, expected_sample_types);
            assert_samples_eq(
                &profile,
                &samples_with_timestamps,
                &samples_without_timestamps,
                &FxIndexMap::default(),
            );
        })
}

#[test]
fn fuzz_add_sample_with_fixed_sample_length() {
    let sample_length_gen = if cfg!(miri) { 1..=8usize } else { 1..=64usize };

    bolero::check!()
        .with_generator(sample_length_gen)
        .and_then(|sample_len| {
            let sample_types = Vec::<owned_types::ValueType>::gen().with().len(sample_len);

            let timestamps = Option::<Timestamp>::gen();
            let locations = Vec::<Location>::gen();
            let values = Vec::<i64>::gen().with().len(sample_len);
            // Generate labels with unique keys
            let labels = HashSet::<Label>::gen();

            let samples =
                Vec::<(Option<Timestamp>, Vec<Location>, Vec<i64>, HashSet<Label>)>::gen()
                    .with()
                    .values((timestamps, locations, values, labels));
            (sample_types, samples)
        })
        .for_each(|(sample_types, samples)| {
            let api_sample_types: Vec<_> = sample_types.iter().map(api::ValueType::from).collect();
            let mut profile = Profile::new(SystemTime::now(), &api_sample_types, None);
            let mut samples_with_timestamps = Vec::new();
            let mut samples_without_timestamps: HashMap<(&Vec<Location>, &Vec<Label>), Vec<i64>> =
                HashMap::new();

            let samples: Vec<(&Option<Timestamp>, Sample)> = samples
                .iter()
                .map(|(timestamp, locations, values, labels)| {
                    (
                        timestamp,
                        Sample {
                            locations: locations.clone(),
                            values: values.clone(),
                            labels: labels.clone().into_iter().collect::<Vec<Label>>(),
                        },
                    )
                })
                .collect();

            for (timestamp, sample) in samples.iter() {
                profile
                    .add_sample(sample.into(), **timestamp)
                    .expect("Failed to add sample");
                if timestamp.is_some() {
                    samples_with_timestamps.push(sample);
                } else if let Some(existing_values) =
                    samples_without_timestamps.get_mut(&(&sample.locations, &sample.labels))
                {
                    existing_values
                        .iter_mut()
                        .zip(sample.values.iter())
                        .for_each(|(a, b)| *a = a.saturating_add(*b));
                } else {
                    samples_without_timestamps
                        .insert((&sample.locations, &sample.labels), sample.values.clone());
                }
            }
            let serialized_profile =
                pprof::roundtrip_to_pprof(profile).expect("Failed to roundtrip to pprof");

            assert_sample_types_eq(&serialized_profile, sample_types);
            assert_samples_eq(
                &serialized_profile,
                &samples_with_timestamps,
                &samples_without_timestamps,
                &FxIndexMap::default(),
            );
        });
}

#[test]
fn fuzz_add_endpoint() {
    bolero::check!()
        .with_type::<Vec<(u64, String)>>()
        .for_each(|endpoints| {
            let mut profile = Profile::new(SystemTime::now(), &[], None);
            for (local_root_span_id, endpoint) in endpoints {
                profile
                    .add_endpoint(*local_root_span_id, endpoint.into())
                    .expect("add_endpoint to succeed");
            }
            pprof::roundtrip_to_pprof(profile).expect("roundtrip_to_pprof to succeed");
        });
}

#[test]
fn fuzz_add_endpoint_count() {
    bolero::check!()
        .with_type::<Vec<(String, i64)>>()
        .for_each(|endpoint_counts| {
            let mut profile = Profile::new(SystemTime::now(), &[], None);
            for (endpoint, count) in endpoint_counts {
                profile
                    .add_endpoint_count(endpoint.into(), *count)
                    .expect("add_endpoint_count to succeed");
            }
            pprof::roundtrip_to_pprof(profile).expect("roundtrip_to_pprof to succeed");
        });
}

#[derive(Debug, TypeGenerator)]
enum Operation {
    AddSample(Option<Timestamp>, Sample),
    AddEndpoint(u64, String),
}

#[derive(Debug, TypeGenerator)]
struct ApiFunctionCalls {
    sample_types: Vec<owned_types::ValueType>,
    operations: Vec<Operation>,
}

#[test]
fn fuzz_api_function_calls() {
    let sample_length_gen = if cfg!(miri) { 1..=8usize } else { 1..=64usize };

    bolero::check!()
        .with_generator(sample_length_gen)
        .and_then(|sample_len| {
            let sample_types = Vec::<owned_types::ValueType>::gen().with().len(sample_len);
            let operations = Vec::<Operation>::gen();

            (sample_types, operations)
        })
        .for_each(|(sample_types, operations)| {
            let api_sample_types: Vec<_> = sample_types.iter().map(api::ValueType::from).collect();
            let mut profile = Profile::new(SystemTime::now(), &api_sample_types, None);
            let mut samples_with_timestamps: Vec<&Sample> = Vec::new();
            let mut samples_without_timestamps: HashMap<(&Vec<Location>, &Vec<Label>), Vec<i64>> =
                HashMap::new();
            let mut endpoint_mappings: FxIndexMap<u64, &String> = FxIndexMap::default();

            for operation in operations {
                match operation {
                    Operation::AddSample(timestamp, sample) => {
                        fuzz_add_sample(
                            timestamp,
                            sample,
                            sample_types,
                            &mut profile,
                            &mut samples_with_timestamps,
                            &mut samples_without_timestamps,
                        );
                    }
                    Operation::AddEndpoint(local_root_span_id, endpoint) => {
                        profile
                            .add_endpoint(*local_root_span_id, endpoint.into())
                            .expect("add_endpoint to succeed");
                        endpoint_mappings.insert(*local_root_span_id, endpoint);
                    }
                }
            }

            let pprof_profile = pprof::roundtrip_to_pprof(profile).unwrap();
            assert_sample_types_eq(&pprof_profile, sample_types);
            assert_samples_eq(
                &pprof_profile,
                &samples_with_timestamps,
                &samples_without_timestamps,
                &endpoint_mappings,
            );
        })
}
