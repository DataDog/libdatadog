// Copyright 2021-Present Datadog, Inc. https://www.datadoghq.com/
// SPDX-License-Identifier: Apache-2.0

#[cfg(test)]
use bolero_generator::{TypeGeneratorWithParams, ValueGenerator};

use crate::api;

#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
#[cfg_attr(test, derive(bolero_generator::TypeGenerator))]
pub struct Function {
    /// Name of the function, in human-readable form if available.
    pub name: Box<str>,

    /// Name of the function, as identified by the system.
    /// For instance, it can be a C++ mangled name.
    pub system_name: Box<str>,

    /// Source file containing the function.
    pub filename: Box<str>,

    /// Line number in source file.
    pub start_line: i64,
}

impl<'a> From<&'a Function> for api::Function<'a> {
    fn from(value: &'a Function) -> Self {
        Self {
            name: &value.name,
            system_name: &value.system_name,
            filename: &value.filename,
            start_line: value.start_line,
        }
    }
}

#[derive(Clone, Debug, Default)]
#[cfg_attr(test, derive(bolero_generator::TypeGenerator))]
pub struct Label {
    pub key: Box<str>,

    /// At most one of the following must be present
    pub str: Option<String>,
    pub num: i64,

    /// Should only be present when num is present.
    /// Specifies the units of num.
    /// Use arbitrary string (for example, "requests") as a custom count unit.
    /// If no unit is specified, consumer may apply heuristic to deduce the unit.
    /// Consumers may also  interpret units like "bytes" and "kilobytes" as memory
    /// units and units like "seconds" and "nanoseconds" as time units,
    /// and apply appropriate unit conversions to these.
    pub num_unit: Option<Box<str>>,
}

impl PartialEq for Label {
    fn eq(&self, other: &Self) -> bool {
        self.key == other.key
    }
}

impl Eq for Label {}

impl std::hash::Hash for Label {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.key.hash(state)
    }
}

impl<'a> From<&'a Label> for api::Label<'a> {
    fn from(value: &'a Label) -> Self {
        Self {
            key: &value.key,
            str: value.str.as_deref(),
            num: value.num,
            num_unit: value.num_unit.as_deref(),
        }
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
#[cfg_attr(test, derive(bolero_generator::TypeGenerator))]
pub struct Line {
    /// The corresponding profile.Function for this line.
    pub function: Function,

    /// Line number in source code.
    pub line: i64,
}

impl<'a> From<&'a Line> for api::Line<'a> {
    fn from(value: &'a Line) -> Self {
        Self {
            function: (&value.function).into(),
            line: value.line,
        }
    }
}

#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
#[cfg_attr(test, derive(bolero_generator::TypeGenerator))]
pub struct Location {
    pub mapping: Mapping,
    pub function: Function,

    /// The instruction address for this location, if available.  It
    /// should be within [Mapping.memory_start...Mapping.memory_limit]
    /// for the corresponding mapping. A non-leaf address may be in the
    /// middle of a call instruction. It is up to display tools to find
    /// the beginning of the instruction if necessary.
    pub address: u64,
    pub line: i64,
}

impl<'a> From<&'a Location> for api::Location<'a> {
    fn from(value: &'a Location) -> Self {
        Self {
            mapping: (&value.mapping).into(),
            function: (&value.function).into(),
            address: value.address,
            line: value.line,
        }
    }
}

#[derive(Clone, Debug, Default, Eq, PartialEq, Hash)]
#[cfg_attr(test, derive(bolero_generator::TypeGenerator))]
pub struct Mapping {
    /// Address at which the binary (or DLL) is loaded into memory.
    pub memory_start: u64,

    /// The limit of the address range occupied by this mapping.
    pub memory_limit: u64,

    /// Offset in the binary that corresponds to the first mapped address.
    pub file_offset: u64,

    /// The object this entry is loaded from.  This can be a filename on
    /// disk for the main binary and shared libraries, or virtual
    /// abstractions like "[vdso]".
    pub filename: Box<str>,

    /// A string that uniquely identifies a particular program version
    /// with high probability. E.g., for binaries generated by GNU tools,
    /// it could be the contents of the .note.gnu.build-id field.
    pub build_id: Box<str>,
}

impl<'a> From<&'a Mapping> for api::Mapping<'a> {
    fn from(value: &'a Mapping) -> Self {
        Self {
            memory_start: value.memory_start,
            memory_limit: value.memory_limit,
            file_offset: value.file_offset,
            filename: &value.filename,
            build_id: &value.build_id,
        }
    }
}

#[derive(Clone, Debug)]
#[cfg_attr(test, derive(bolero_generator::TypeGenerator))]
pub struct Period {
    pub typ: ValueType,
    pub value: i64,
}

impl<'a> From<&'a api::Period<'a>> for Period {
    #[inline]
    fn from(period: &'a api::Period<'a>) -> Self {
        Self {
            typ: ValueType::from(&period.r#type),
            value: period.value,
        }
    }
}

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Sample {
    /// The leaf is at locations[0].
    pub locations: Vec<Location>,

    /// The type and unit of each value is defined by the corresponding
    /// entry in Profile.sample_type. All samples must have the same
    /// number of values, the same as the length of Profile.sample_type.
    /// When aggregating multiple samples into a single sample, the
    /// result has a list of values that is the element-wise sum of the
    /// lists of the originals.
    pub values: Vec<i64>,

    /// label includes additional context for this sample. It can include
    /// things like a thread id, allocation size, etc
    pub labels: Vec<Label>,
}

#[cfg(test)]
impl bolero_generator::TypeGenerator for Sample {
    fn generate<D: bolero_generator::Driver>(driver: &mut D) -> Option<Self> {
        let locations = Vec::<Location>::gen_with().generate(driver)?;
        let values = Vec::<i64>::gen_with().generate(driver)?;
        let mut labels = std::collections::HashSet::<Label>::gen_with().generate(driver)?;

        // Ensure that the label has "local root span id" key
        // Generate non-zero i64 value for the label
        let num = i64::gen().generate(driver)?;
        if num == 0 {
            return None;
        }

        labels.insert(Label {
            key: "local root span id".into(),
            str: None,
            num,
            num_unit: None,
        });
        let labels = labels.into_iter().collect();
        Some(Self {
            locations,
            values,
            labels,
        })
    }
}

impl std::hash::Hash for Sample {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.locations.hash(state);
        self.labels.hash(state);
    }
}

impl<'a> From<&'a Sample> for api::Sample<'a> {
    fn from(value: &'a Sample) -> Self {
        Self {
            locations: value.locations.iter().map(api::Location::from).collect(),
            values: value.values.clone(),
            labels: value.labels.iter().map(api::Label::from).collect(),
        }
    }
}

#[cfg(test)]
impl Sample {
    /// Checks if the sample is well formed.  Useful in testing.
    pub fn is_well_formed(&self) -> bool {
        let labels_are_unique = {
            let mut uniq = std::collections::HashSet::new();
            self.labels.iter().map(|l| &l.key).all(|x| uniq.insert(x))
        };
        labels_are_unique
    }
}

#[derive(Clone, Debug)]
#[cfg_attr(test, derive(bolero_generator::TypeGenerator))]
pub struct ValueType {
    pub typ: Box<str>,
    pub unit: Box<str>,
}

impl<'a> From<&'a api::ValueType<'a>> for ValueType {
    #[inline]
    fn from(value_type: &'a api::ValueType<'a>) -> Self {
        Self {
            typ: String::from(value_type.r#type).into(),
            unit: String::from(value_type.unit).into(),
        }
    }
}

impl<'a> From<&'a ValueType> for api::ValueType<'a> {
    fn from(value: &'a ValueType) -> Self {
        Self::new(&value.typ, &value.unit)
    }
}
