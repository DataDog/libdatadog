// Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2023-Present Datadog, Inc.

use super::{Id, Item, PprofItem};
use crate::profile::{pprof, StringId};
use std::num::NonZeroU32;

#[derive(Eq, PartialEq, Hash)]
pub struct Mapping {
    /// Address at which the binary (or DLL) is loaded into memory.
    pub memory_start: u64,
    /// The limit of the address range occupied by this mapping.
    pub memory_limit: u64,
    /// Offset in the binary that corresponds to the first mapped address.
    pub file_offset: u64,

    /// The object this entry is loaded from.  This can be a filename on
    /// disk for the main binary and shared libraries, or virtual
    /// abstractions like "[vdso]".
    pub filename: StringId,

    /// A string that uniquely identifies a particular program version
    /// with high probability. E.g., for binaries generated by GNU tools,
    /// it could be the contents of the .note.gnu.build-id field.
    pub build_id: StringId,
}

impl Item for Mapping {
    type Id = MappingId;
}

impl PprofItem for Mapping {
    type PprofMessage = pprof::Mapping;

    fn to_pprof(&self, id: Self::Id) -> Self::PprofMessage {
        pprof::Mapping {
            id: id.to_raw_id(),
            memory_start: self.memory_start,
            memory_limit: self.memory_limit,
            file_offset: self.file_offset,
            filename: self.filename.to_raw_id(),
            build_id: self.build_id.to_raw_id(),
            ..pprof::Mapping::default() // todo: support detailed Mapping info
        }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, PartialOrd, Ord)]
#[repr(transparent)]
pub struct MappingId(NonZeroU32);

impl Id for MappingId {
    type RawId = u64;

    fn from_offset(v: usize) -> Self {
        let index: u32 = v.try_into().expect("MappingId to fit into a u32");

        // PProf reserves location 0.
        // Both this, and the serialization of the table, add 1 to avoid the 0 element
        let index = index.checked_add(1).expect("MappingId to fit into a u32");
        // Safety: the `checked_add(1).expect(...)` guards this from ever being zero.
        let index = unsafe { NonZeroU32::new_unchecked(index) };
        Self(index)
    }

    fn to_raw_id(&self) -> Self::RawId {
        self.0.get().into()
    }
}
