// Copyright 2021-Present Datadog, Inc. https://www.datadoghq.com/
// SPDX-License-Identifier: Apache-2.0

//! Add file attributes to JUnit XML test reports
//!
//! This module enriches JUnit XML files generated by cargo-nextest with `file` attributes
//! on `<testcase>` elements. It uses cargo metadata to map Rust test paths to source files.

use anyhow::{anyhow, Context, Result};
use cargo_metadata::{CargoOpt, MetadataCommand};
use quick_xml::events::{BytesStart, Event};
use quick_xml::{Reader, Writer};
use std::collections::HashMap;
use std::fs;
use std::io::Cursor;
use std::path::{Path, PathBuf};

/// Package name used for nextest setup scripts in the target lookup.
/// Nextest uses classnames like "@setup-script:script-name" for setup scripts.
const SETUP_SCRIPT_PACKAGE: &str = "@setup-script";
/// Prefix for setup script classnames (includes the colon separator).
const SETUP_SCRIPT_PREFIX: &str = "@setup-script:";

/// Lookup table for resolving test classnames to source files.
///
/// Uses a primary map keyed by `(package_name, target_name)` for all targets.
/// A secondary alias map handles cases where lib target names differ from package names
/// (e.g., `libdd-profiling-ffi` has lib target `datadog_profiling_ffi`).
///
/// Nextest generates different classname formats:
/// - Integration tests: `classname="package::target_name"` (e.g.,
///   `libdd-trace-utils::test_send_data`)
/// - Unit tests: `classname="package"` (e.g., `libdd-trace-utils`)
///
/// For unit tests, we first try `(package, package)` assuming the lib name matches.
/// If not found, we check the alias map to get the actual lib target name.
pub struct TargetLookup {
    /// Map from (package_name, target_name) to source path for all targets
    targets: HashMap<(String, String), PathBuf>,
    /// Map from package_name to lib_target_name for packages where they differ
    lib_name_aliases: HashMap<String, String>,
}

impl TargetLookup {
    pub fn new() -> Self {
        Self {
            targets: HashMap::new(),
            lib_name_aliases: HashMap::new(),
        }
    }

    /// Normalize a name by replacing hyphens with underscores.
    /// Cargo normalizes crate names this way internally.
    fn normalize(name: &str) -> String {
        name.replace('-', "_")
    }

    /// Insert a lib-like target (lib or proc-macro).
    /// If the lib target name differs from the package name, stores an alias for lookup.
    pub fn insert_lib(&mut self, package_name: &str, target_name: &str, src_path: PathBuf) {
        let package_name = Self::normalize(package_name);
        let target_name = Self::normalize(target_name);
        if package_name != target_name {
            self.lib_name_aliases
                .insert(package_name.clone(), target_name.clone());
        }
        self.targets.insert((package_name, target_name), src_path);
    }

    /// Insert a target (integration test or binary).
    pub fn insert_target(&mut self, package_name: &str, target_name: &str, src_path: PathBuf) {
        let package_name = Self::normalize(package_name);
        let target_name = Self::normalize(target_name);
        self.targets.insert((package_name, target_name), src_path);
    }

    /// Insert a setup script entry.
    /// Uses `SETUP_SCRIPT_PACKAGE` as the package name so it can be looked up from
    /// classnames like "@setup-script:prebuild-bin-tests".
    fn insert_setup_script(&mut self, script_name: &str, src_path: PathBuf) {
        // Don't normalize - script names can have hyphens and we want exact match
        self.targets.insert(
            (SETUP_SCRIPT_PACKAGE.to_string(), script_name.to_string()),
            src_path,
        );
    }

    /// Look up a target's source path.
    ///
    /// - If `target_name` is `Some`, looks up directly by `(package, target)`
    /// - If `target_name` is `None`, tries `(package, package)` first, then checks the alias map
    ///   for packages where lib name differs from package name
    pub fn get(&self, package_name: &str, target_name: Option<&str>) -> Option<&PathBuf> {
        // Setup scripts use SETUP_SCRIPT_PACKAGE as package name and shouldn't be normalized
        if package_name == SETUP_SCRIPT_PACKAGE {
            let target_name = target_name?;
            return self
                .targets
                .get(&(package_name.to_string(), target_name.to_string()));
        }

        let package_name = Self::normalize(package_name);
        match target_name {
            Some(name) => {
                let target_name = Self::normalize(name);
                self.targets.get(&(package_name, target_name))
            }
            None => {
                // Try (package, package) first - the common case
                self.targets
                    .get(&(package_name.clone(), package_name.clone()))
                    .or_else(|| {
                        // Fall back to alias lookup for mismatched lib names
                        let lib_name = self.lib_name_aliases.get(&package_name)?;
                        self.targets.get(&(package_name, lib_name.clone()))
                    })
            }
        }
    }
}

impl Default for TargetLookup {
    fn default() -> Self {
        Self::new()
    }
}

/// Build a TargetLookup from cargo metadata.
pub fn build_target_lookup(manifest_path: Option<&Path>) -> Result<(TargetLookup, PathBuf)> {
    let mut cmd = MetadataCommand::new();
    cmd.features(CargoOpt::AllFeatures);
    cmd.no_deps();

    if let Some(path) = manifest_path {
        cmd.manifest_path(path);
    }

    let metadata = cmd.exec().context("failed to run cargo metadata")?;
    let workspace_root = metadata.workspace_root.clone().into_std_path_buf();

    let mut lookup = TargetLookup::new();

    for package in metadata.packages {
        for target in package.targets {
            let kind = target.kind.first().map(|s| s.as_str()).unwrap_or("unknown");

            let src_path = target.src_path.into_std_path_buf();

            match kind {
                "lib" | "proc-macro" => {
                    lookup.insert_lib(&package.name, &target.name, src_path);
                }
                "test" => {
                    lookup.insert_target(&package.name, &target.name, src_path);
                }
                "bin" => {
                    lookup.insert_target(&package.name, &target.name, src_path);
                }
                _ => {}
            }
        }
    }

    // Load setup scripts from nextest.toml if it exists
    load_setup_scripts(&workspace_root, &mut lookup);

    Ok((lookup, workspace_root))
}

/// Load setup scripts from nextest.toml and add them to the lookup.
fn load_setup_scripts(workspace_root: &Path, lookup: &mut TargetLookup) {
    let nextest_path = workspace_root.join(".config/nextest.toml");
    let content = match fs::read_to_string(&nextest_path) {
        Ok(c) => c,
        Err(_) => return, // No nextest.toml, nothing to do
    };

    let table: toml::Table = match content.parse() {
        Ok(t) => t,
        Err(_) => return, // Invalid TOML, skip
    };

    // Look for [script.X] sections
    let script_section = match table.get("script").and_then(|v| v.as_table()) {
        Some(s) => s,
        None => return,
    };

    for (script_name, script_value) in script_section {
        let command = match script_value.get("command").and_then(|v| v.as_str()) {
            Some(c) => c,
            None => continue,
        };

        // Parse "cargo run -p <package> --bin <binary>" to get package and binary
        if let Some((package, binary)) = parse_cargo_run_command(command) {
            // Look up the binary's source path and insert as setup script
            if let Some(src_path) = lookup.get(&package, Some(&binary)).cloned() {
                lookup.insert_setup_script(script_name, src_path);
            }
        }
    }
}

/// Parse a cargo run command to extract package and binary names.
/// Expected format: "cargo run -p <package> --bin <binary>" (flags can be in any order)
fn parse_cargo_run_command(command: &str) -> Option<(String, String)> {
    let parts: Vec<&str> = command.split_whitespace().collect();

    // Must start with "cargo run"
    if parts.len() < 2 || parts[0] != "cargo" || parts[1] != "run" {
        return None;
    }

    let mut package = None;
    let mut binary = None;
    let mut i = 2;

    while i < parts.len() {
        match parts[i] {
            "-p" | "--package" => {
                if i + 1 < parts.len() {
                    package = Some(parts[i + 1].to_string());
                    i += 2;
                } else {
                    i += 1;
                }
            }
            "--bin" => {
                if i + 1 < parts.len() {
                    binary = Some(parts[i + 1].to_string());
                    i += 2;
                } else {
                    i += 1;
                }
            }
            _ => i += 1,
        }
    }

    match (package, binary) {
        (Some(p), Some(b)) => Some((p, b)),
        _ => None,
    }
}

/// Process the JUnit XML and add file attributes to testcase elements.
pub fn process_junit_xml(
    xml: &str,
    targets: &TargetLookup,
    workspace_root: &Path,
) -> Result<String> {
    let mut reader = Reader::from_str(xml);
    reader.config_mut().trim_text(false);

    let mut writer = Writer::new(Cursor::new(Vec::new()));

    loop {
        match reader.read_event() {
            Ok(Event::Start(ref e)) => {
                if e.name().as_ref() == b"testcase" {
                    let elem = add_file_to_testcase(e, targets, workspace_root);
                    writer.write_event(Event::Start(elem))?;
                } else {
                    writer.write_event(Event::Start(e.clone()))?;
                }
            }
            Ok(Event::Empty(ref e)) => {
                if e.name().as_ref() == b"testcase" {
                    let elem = add_file_to_testcase(e, targets, workspace_root);
                    writer.write_event(Event::Empty(elem))?;
                } else {
                    writer.write_event(Event::Empty(e.clone()))?;
                }
            }
            Ok(Event::Eof) => break,
            Ok(e) => writer.write_event(e)?,
            Err(e) => return Err(anyhow!("XML parse error: {}", e)),
        }
    }

    let result = writer.into_inner().into_inner();
    String::from_utf8(result).context("output is not valid UTF-8")
}

/// Add file attribute to a testcase element
fn add_file_to_testcase(
    elem: &BytesStart,
    targets: &TargetLookup,
    workspace_root: &Path,
) -> BytesStart<'static> {
    let mut testcase_name = None;
    let mut classname = None;

    for attr in elem.attributes().filter_map(|a| a.ok()) {
        match attr.key.as_ref() {
            b"name" => testcase_name = Some(String::from_utf8_lossy(&attr.value).to_string()),
            b"classname" => classname = Some(String::from_utf8_lossy(&attr.value).to_string()),
            _ => {}
        }
    }

    let file_path = resolve_file_path(
        classname.as_deref(),
        testcase_name.as_deref(),
        targets,
        workspace_root,
    );

    // Clone the element and add file attribute if we found a path
    let mut new_elem = elem.to_owned();
    if let Some(path) = file_path {
        new_elem.push_attribute(("file", path.as_str()));
    }

    new_elem
}

/// Convert an absolute path to a workspace-relative path with normalized separators
fn to_relative_path(path: &Path, workspace_root: &Path) -> String {
    let relative = path.strip_prefix(workspace_root).unwrap_or(path);
    // Normalize path separators to forward slashes for cross-platform CODEOWNERS compatibility
    relative.to_string_lossy().replace('\\', "/")
}

/// Resolve file path for a setup script
fn resolve_setup_script_path(
    script_name: &str,
    targets: &TargetLookup,
    workspace_root: &Path,
) -> Option<String> {
    let src_path = targets.get(SETUP_SCRIPT_PACKAGE, Some(script_name))?;
    Some(to_relative_path(src_path, workspace_root))
}

/// Resolve file path for a unit test, trying to find the specific module file
fn resolve_unit_test_path(
    src_path: &Path,
    testcase_name: Option<&str>,
    workspace_root: &Path,
) -> String {
    // Try to find the module file from the test name
    // Test name is like "trace_utils::tests::test_compute_top_level"
    // We want to find src/trace_utils.rs or src/trace_utils/mod.rs
    if let Some(test_name) = testcase_name {
        if let Some(src_dir) = src_path.parent() {
            if let Some(file_path) = resolve_module_file(test_name, src_dir, workspace_root) {
                return file_path;
            }
        }
    }
    // Fallback to lib.rs
    to_relative_path(src_path, workspace_root)
}

/// Resolve a file path from classname using cargo metadata
fn resolve_file_path(
    classname: Option<&str>,
    testcase_name: Option<&str>,
    targets: &TargetLookup,
    workspace_root: &Path,
) -> Option<String> {
    let classname = classname?;

    // Handle setup scripts: classname is "@setup-script:script_name"
    if let Some(script_name) = classname.strip_prefix(SETUP_SCRIPT_PREFIX) {
        return resolve_setup_script_path(script_name, targets, workspace_root);
    }

    // Parse classname: "package::target" for integration tests, "package" for unit tests
    let parts: Vec<&str> = classname.split("::").collect();
    let package_name = parts.first()?;
    let target_name = parts.get(1).copied();

    let src_path = targets.get(package_name, target_name)?;

    if target_name.is_some() {
        // Integration test - return the test file directly
        Some(to_relative_path(src_path, workspace_root))
    } else {
        // Unit test - try to find module file, fallback to lib.rs
        Some(resolve_unit_test_path(
            src_path,
            testcase_name,
            workspace_root,
        ))
    }
}

/// Try to find the source file for a unit test based on its module path
fn resolve_module_file(test_name: &str, src_dir: &Path, workspace_root: &Path) -> Option<String> {
    // Test name is like "trace_utils::tests::test_fn" or "span::trace_utils::tests::test_fn"
    // Extract module parts before "tests"
    let parts: Vec<&str> = test_name.split("::").collect();

    // Find the "tests" module and take everything before it
    let module_parts: Vec<&str> = parts
        .iter()
        .take_while(|&&p| p != "tests")
        .copied()
        .collect();

    if module_parts.is_empty() {
        return None;
    }

    // Try module_path.rs (e.g., src/trace_utils.rs or src/span/trace_utils.rs)
    let module_file = src_dir.join(format!("{}.rs", module_parts.join("/")));
    if module_file.exists() {
        return Some(to_relative_path(&module_file, workspace_root));
    }

    // Try module_path/mod.rs (e.g., src/trace_utils/mod.rs)
    let mod_file = src_dir.join(format!("{}/mod.rs", module_parts.join("/")));
    if mod_file.exists() {
        return Some(to_relative_path(&mod_file, workspace_root));
    }

    None
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_target_lookup_normalizes_hyphens() {
        let mut lookup = TargetLookup::new();
        lookup.insert_lib("my-package", "my-package", PathBuf::from("/src/lib.rs"));

        // Should find with hyphens
        assert!(lookup.get("my-package", None).is_some());
        // Should find with underscores
        assert!(lookup.get("my_package", None).is_some());
    }

    #[test]
    fn test_target_lookup_lib_alias() {
        let mut lookup = TargetLookup::new();
        // Package name differs from lib target name
        lookup.insert_lib(
            "libdd-profiling-ffi",
            "datadog_profiling_ffi",
            PathBuf::from("/src/lib.rs"),
        );

        // Should find via alias
        let result = lookup.get("libdd-profiling-ffi", None);
        assert!(result.is_some());
        assert_eq!(result.unwrap(), &PathBuf::from("/src/lib.rs"));
    }

    #[test]
    fn test_target_lookup_test_target() {
        let mut lookup = TargetLookup::new();
        lookup.insert_target(
            "libdd-trace-utils",
            "test_send_data",
            PathBuf::from("/tests/test_send_data.rs"),
        );

        let result = lookup.get("libdd-trace-utils", Some("test_send_data"));
        assert!(result.is_some());
        assert_eq!(result.unwrap(), &PathBuf::from("/tests/test_send_data.rs"));
    }

    #[test]
    fn test_process_junit_xml_adds_file_attribute() {
        let mut lookup = TargetLookup::new();
        lookup.insert_lib(
            "my-crate",
            "my-crate",
            PathBuf::from("/workspace/my-crate/src/lib.rs"),
        );

        let input = r#"<?xml version="1.0" encoding="UTF-8"?>
<testsuites>
  <testsuite name="my-crate">
    <testcase classname="my-crate" name="tests::test_foo" />
  </testsuite>
</testsuites>"#;

        let workspace_root = PathBuf::from("/workspace");
        let result = process_junit_xml(input, &lookup, &workspace_root).unwrap();

        assert!(result.contains(r#"file="my-crate/src/lib.rs""#));
    }

    #[test]
    fn test_process_junit_xml_integration_test() {
        let mut lookup = TargetLookup::new();
        lookup.insert_target(
            "my-crate",
            "integration_test",
            PathBuf::from("/workspace/my-crate/tests/integration_test.rs"),
        );

        let input = r#"<?xml version="1.0" encoding="UTF-8"?>
<testsuites>
  <testsuite name="my-crate::integration_test">
    <testcase classname="my-crate::integration_test" name="test_something" />
  </testsuite>
</testsuites>"#;

        let workspace_root = PathBuf::from("/workspace");
        let result = process_junit_xml(input, &lookup, &workspace_root).unwrap();

        assert!(result.contains(r#"file="my-crate/tests/integration_test.rs""#));
    }

    #[test]
    fn test_process_junit_xml_setup_script() {
        let mut lookup = TargetLookup::new();
        // Simulate what load_setup_scripts does - insert with @setup-script as package
        lookup.insert_setup_script(
            "prebuild-bin-tests",
            PathBuf::from("/workspace/bin_tests/src/bin/prebuild.rs"),
        );

        let input = r#"<?xml version="1.0" encoding="UTF-8"?>
<testsuites>
  <testsuite name="@setup-script:prebuild-bin-tests">
    <testcase classname="@setup-script:prebuild-bin-tests" name="prebuild-bin-tests" />
  </testsuite>
</testsuites>"#;

        let workspace_root = PathBuf::from("/workspace");
        let result = process_junit_xml(input, &lookup, &workspace_root).unwrap();

        assert!(result.contains(r#"file="bin_tests/src/bin/prebuild.rs""#));
    }

    #[test]
    fn test_parse_cargo_run_command() {
        // Standard format
        let result = parse_cargo_run_command("cargo run -p bin_tests --bin prebuild");
        assert_eq!(
            result,
            Some(("bin_tests".to_string(), "prebuild".to_string()))
        );

        // Different flag order
        let result = parse_cargo_run_command("cargo run --bin prebuild -p bin_tests");
        assert_eq!(
            result,
            Some(("bin_tests".to_string(), "prebuild".to_string()))
        );

        // With --package instead of -p
        let result = parse_cargo_run_command("cargo run --package bin_tests --bin prebuild");
        assert_eq!(
            result,
            Some(("bin_tests".to_string(), "prebuild".to_string()))
        );

        // Missing binary
        let result = parse_cargo_run_command("cargo run -p bin_tests");
        assert_eq!(result, None);

        // Not a cargo run command
        let result = parse_cargo_run_command("cargo build -p bin_tests");
        assert_eq!(result, None);
    }
}
