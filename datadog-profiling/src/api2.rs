// Copyright 2025-Present Datadog, Inc. https://www.datadoghq.com/
// SPDX-License-Identifier: Apache-2.0

#[derive(Copy, Clone, Debug, Default)]
#[repr(C)]
pub struct Mapping2 {
    /// Address at which the binary (or DLL) is loaded into memory.
    pub memory_start: u64,

    /// The limit of the address range occupied by this mapping.
    pub memory_limit: u64,

    /// Offset in the binary that corresponds to the first mapped address.
    pub file_offset: u64,

    /// The object this entry is loaded from.  This can be a filename on
    /// disk for the main binary and shared libraries, or virtual
    /// abstractions like "[vdso]".
    pub filename: StringId2,

    /// A string that uniquely identifies a particular program version
    /// with high probability. E.g., for binaries generated by GNU tools,
    /// it could be the contents of the .note.gnu.build-id field.
    pub build_id: StringId2,
}

#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct MappingId2(*mut Mapping2);

// todo: when MSRV is 1.88.0+, derive Default
impl Default for MappingId2 {
    fn default() -> Self {
        Self(core::ptr::null_mut())
    }
}

impl MappingId2 {
    pub fn is_empty(self) -> bool {
        self.0.is_null()
    }

    /// # Safety
    /// The pointer object must still be alive. In general this means the
    /// profiles dictionary it came from must be alive.
    pub unsafe fn read(self) -> Option<Mapping2> {
        if self.is_empty() {
            None
        } else {
            Some(self.0.read())
        }
    }
}

#[derive(Copy, Clone, Debug, Default)]
#[repr(C)]
pub struct Function2 {
    /// Name of the function, in human-readable form if available.
    pub name: StringId2,

    /// Name of the function, as identified by the system.
    /// For instance, it can be a C++ mangled name.
    pub system_name: StringId2,

    /// Source file containing the function.
    pub file_name: StringId2,
}

#[derive(Clone, Copy, Debug)]
#[repr(transparent)]
pub struct FunctionId2(*mut Function2);

// todo: when MSRV is 1.88.0+, derive Default
impl Default for FunctionId2 {
    fn default() -> Self {
        Self(core::ptr::null_mut())
    }
}

impl FunctionId2 {
    pub fn is_empty(self) -> bool {
        self.0.is_null()
    }

    /// # Safety
    /// The pointer object must still be alive. In general this means the
    /// profiles dictionary it came from must be alive.
    pub unsafe fn read(self) -> Option<Function2> {
        if self.is_empty() {
            None
        } else {
            Some(self.0.read())
        }
    }
}

#[derive(Copy, Clone, Debug, Default)]
#[repr(C)]
pub struct Location2 {
    pub mapping: MappingId2,
    pub function: FunctionId2,

    /// The instruction address for this location, if available.  It
    /// should be within [Mapping.memory_start...Mapping.memory_limit]
    /// for the corresponding mapping. A non-leaf address may be in the
    /// middle of a call instruction. It is up to display tools to find
    /// the beginning of the instruction if necessary.
    pub address: u64,
    pub line: i64,
}

#[derive(Copy, Clone, Debug, Default)]
pub struct Label<'a> {
    pub key: StringId2,

    /// At most one of `.str` and `.num` should not be empty.
    pub str: &'a str,
    pub num: i64,

    /// Should only be present when num is present.
    /// Specifies the units of num.
    /// Use arbitrary string (for example, "requests") as a custom count unit.
    /// If no unit is specified, consumer may apply heuristic to deduce the unit.
    /// Consumers may also  interpret units like "bytes" and "kilobytes" as memory
    /// units and units like "seconds" and "nanoseconds" as time units,
    /// and apply appropriate unit conversions to these.
    pub num_unit: &'a str,
}

impl<'a> Label<'a> {
    pub const fn str(key: StringId2, str: &'a str) -> Label<'a> {
        Label {
            key,
            str,
            num: 0,
            num_unit: "",
        }
    }

    pub const fn num(key: StringId2, num: i64, num_unit: &'a str) -> Label<'a> {
        Label {
            key,
            str: "",
            num,
            num_unit,
        }
    }
}

/// Represents a pointer to a string's header. Its definition is intentionally obscured.
#[derive(Clone, Copy, Debug)]
pub struct StringHeader(());

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct StringId2(*mut StringHeader);

unsafe impl Send for StringId2 {}

unsafe impl Sync for StringId2 {}

impl Default for StringId2 {
    fn default() -> Self {
        Self::EMPTY
    }
}

impl StringId2 {
    pub const EMPTY: StringId2 = StringId2(core::ptr::null_mut());

    pub fn is_empty(&self) -> bool {
        self.0.is_null()
    }
}
