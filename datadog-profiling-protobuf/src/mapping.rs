// Copyright 2025-Present Datadog, Inc. https://www.datadoghq.com/
// SPDX-License-Identifier: Apache-2.0

use super::{Record, StringOffset, Value, WireType, NO_OPT_ZERO, OPT_ZERO};
use std::io::{self, Write};

/// Represents a mapping in a profile. The boolean fields have been omitted to
/// save bytes/CPU since they are unused in Datadog.
#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, PartialEq)]
#[cfg_attr(test, derive(bolero::generator::TypeGenerator))]
pub struct Mapping {
    /// Unique nonzero id for the mapping.
    pub id: Record<u64, 1, NO_OPT_ZERO>,
    /// Address at which the binary (or DLL) is loaded into memory.
    pub memory_start: Record<u64, 2, OPT_ZERO>,
    /// The limit of the address range occupied by this mapping.
    pub memory_limit: Record<u64, 3, OPT_ZERO>,
    /// Offset in the binary that corresponds to the first mapped address.
    pub file_offset: Record<u64, 4, OPT_ZERO>,
    /// The object this entry is loaded from.  This can be a filename on disk
    /// for the main binary and shared libraries or virtual abstractions like
    /// "\[vdso\]".
    pub filename: Record<StringOffset, 5, OPT_ZERO>,
    /// A string that uniquely identifies a particular program version
    /// with high probability. E.g., for binaries generated by GNU tools,
    /// it could be the contents of the .note.gnu.build-id field.
    pub build_id: Record<StringOffset, 6, OPT_ZERO>,
}

impl Mapping {}

/// # Safety
/// The Default implementation will return all zero-representations.
unsafe impl Value for Mapping {
    const WIRE_TYPE: WireType = WireType::LengthDelimited;

    fn proto_len(&self) -> u64 {
        self.id.proto_len()
            + self.memory_start.proto_len()
            + self.memory_limit.proto_len()
            + self.file_offset.proto_len()
            + self.filename.proto_len()
            + self.build_id.proto_len()
    }

    fn encode<W: Write>(&self, writer: &mut W) -> io::Result<()> {
        self.id.encode(writer)?;
        self.memory_start.encode(writer)?;
        self.memory_limit.encode(writer)?;
        self.file_offset.encode(writer)?;
        self.filename.encode(writer)?;
        self.build_id.encode(writer)
    }
}

#[cfg(feature = "prost_impls")]
impl From<&Mapping> for crate::prost_impls::Mapping {
    fn from(mapping: &Mapping) -> Self {
        Self {
            id: mapping.id.value,
            memory_start: mapping.memory_start.value,
            memory_limit: mapping.memory_limit.value,
            file_offset: mapping.file_offset.value,
            filename: mapping.filename.value.into(),
            build_id: mapping.build_id.value.into(),
            ..Self::default()
        }
    }
}

#[cfg(feature = "prost_impls")]
impl From<Mapping> for crate::prost_impls::Mapping {
    fn from(mapping: Mapping) -> Self {
        Self::from(&mapping)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::prost_impls;
    use prost::Message;

    fn test(mapping: &Mapping) {
        let prost_mapping = prost_impls::Mapping::from(mapping);
        assert_eq!(mapping.id.value, prost_mapping.id);
        assert_eq!(mapping.memory_start.value, prost_mapping.memory_start);
        assert_eq!(mapping.memory_limit.value, prost_mapping.memory_limit);
        assert_eq!(mapping.file_offset.value, prost_mapping.file_offset);
        assert_eq!(i64::from(mapping.filename.value), prost_mapping.filename);
        assert_eq!(i64::from(mapping.build_id.value), prost_mapping.build_id);

        let roundtrip = {
            let mut buffer = Vec::with_capacity(mapping.proto_len() as usize);
            mapping.encode(&mut buffer).unwrap();
            prost_impls::Mapping::decode(buffer.as_slice()).unwrap()
        };
        assert_eq!(roundtrip, prost_mapping);

        let roundtrip2 = {
            let mut buffer = Vec::with_capacity(prost_mapping.encoded_len());
            prost_mapping.encode(&mut buffer).unwrap();
            prost_impls::Mapping::decode(buffer.as_slice()).unwrap()
        };
        assert_eq!(roundtrip, roundtrip2);
    }

    #[test]
    fn roundtrip() {
        bolero::check!().with_type::<Mapping>().for_each(test);
    }
}
